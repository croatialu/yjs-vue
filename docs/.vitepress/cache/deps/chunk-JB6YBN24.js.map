{
  "version": 3,
  "sources": ["../../../../node_modules/lib0/broadcastchannel.js", "../../../../node_modules/y-protocols/sync.js", "../../../../node_modules/y-protocols/awareness.js"],
  "sourcesContent": ["/* eslint-env browser */\n\n/**\n * Helpers for cross-tab communication using broadcastchannel with LocalStorage fallback.\n *\n * ```js\n * // In browser window A:\n * broadcastchannel.subscribe('my events', data => console.log(data))\n * broadcastchannel.publish('my events', 'Hello world!') // => A: 'Hello world!' fires synchronously in same tab\n *\n * // In browser window B:\n * broadcastchannel.publish('my events', 'hello from tab B') // => A: 'hello from tab B'\n * ```\n *\n * @module broadcastchannel\n */\n\n// @todo before next major: use Uint8Array instead as buffer object\n\nimport * as map from './map.js'\nimport * as set from './set.js'\nimport * as buffer from './buffer.js'\nimport * as storage from './storage.js'\n\n/**\n * @typedef {Object} Channel\n * @property {Set<function(any, any):any>} Channel.subs\n * @property {any} Channel.bc\n */\n\n/**\n * @type {Map<string, Channel>}\n */\nconst channels = new Map()\n\n/* c8 ignore start */\nclass LocalStoragePolyfill {\n  /**\n   * @param {string} room\n   */\n  constructor (room) {\n    this.room = room\n    /**\n     * @type {null|function({data:ArrayBuffer}):void}\n     */\n    this.onmessage = null\n    /**\n     * @param {any} e\n     */\n    this._onChange = e => e.key === room && this.onmessage !== null && this.onmessage({ data: buffer.fromBase64(e.newValue || '') })\n    storage.onChange(this._onChange)\n  }\n\n  /**\n   * @param {ArrayBuffer} buf\n   */\n  postMessage (buf) {\n    storage.varStorage.setItem(this.room, buffer.toBase64(buffer.createUint8ArrayFromArrayBuffer(buf)))\n  }\n\n  close () {\n    storage.offChange(this._onChange)\n  }\n}\n/* c8 ignore stop */\n\n// Use BroadcastChannel or Polyfill\n/* c8 ignore next */\nconst BC = typeof BroadcastChannel === 'undefined' ? LocalStoragePolyfill : BroadcastChannel\n\n/**\n * @param {string} room\n * @return {Channel}\n */\nconst getChannel = room =>\n  map.setIfUndefined(channels, room, () => {\n    const subs = set.create()\n    const bc = new BC(room)\n    /**\n     * @param {{data:ArrayBuffer}} e\n     */\n    /* c8 ignore next */\n    bc.onmessage = e => subs.forEach(sub => sub(e.data, 'broadcastchannel'))\n    return {\n      bc, subs\n    }\n  })\n\n/**\n * Subscribe to global `publish` events.\n *\n * @function\n * @param {string} room\n * @param {function(any, any):any} f\n */\nexport const subscribe = (room, f) => {\n  getChannel(room).subs.add(f)\n  return f\n}\n\n/**\n * Unsubscribe from `publish` global events.\n *\n * @function\n * @param {string} room\n * @param {function(any, any):any} f\n */\nexport const unsubscribe = (room, f) => {\n  const channel = getChannel(room)\n  const unsubscribed = channel.subs.delete(f)\n  if (unsubscribed && channel.subs.size === 0) {\n    channel.bc.close()\n    channels.delete(room)\n  }\n  return unsubscribed\n}\n\n/**\n * Publish data to all subscribers (including subscribers on this tab)\n *\n * @function\n * @param {string} room\n * @param {any} data\n * @param {any} [origin]\n */\nexport const publish = (room, data, origin = null) => {\n  const c = getChannel(room)\n  c.bc.postMessage(data)\n  c.subs.forEach(sub => sub(data, origin))\n}\n", "/**\n * @module sync-protocol\n */\n\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\nimport * as Y from 'yjs'\n\n/**\n * @typedef {Map<number, number>} StateMap\n */\n\n/**\n * Core Yjs defines two message types:\n * • YjsSyncStep1: Includes the State Set of the sending client. When received, the client should reply with YjsSyncStep2.\n * • YjsSyncStep2: Includes all missing structs and the complete delete set. When received, the client is assured that it\n *   received all information from the remote client.\n *\n * In a peer-to-peer network, you may want to introduce a SyncDone message type. Both parties should initiate the connection\n * with SyncStep1. When a client received SyncStep2, it should reply with SyncDone. When the local client received both\n * SyncStep2 and SyncDone, it is assured that it is synced to the remote client.\n *\n * In a client-server model, you want to handle this differently: The client should initiate the connection with SyncStep1.\n * When the server receives SyncStep1, it should reply with SyncStep2 immediately followed by SyncStep1. The client replies\n * with SyncStep2 when it receives SyncStep1. Optionally the server may send a SyncDone after it received SyncStep2, so the\n * client knows that the sync is finished.  There are two reasons for this more elaborated sync model: 1. This protocol can\n * easily be implemented on top of http and websockets. 2. The server should only reply to requests, and not initiate them.\n * Therefore it is necessary that the client initiates the sync.\n *\n * Construction of a message:\n * [messageType : varUint, message definition..]\n *\n * Note: A message does not include information about the room name. This must to be handled by the upper layer protocol!\n *\n * stringify[messageType] stringifies a message definition (messageType is already read from the bufffer)\n */\n\nexport const messageYjsSyncStep1 = 0\nexport const messageYjsSyncStep2 = 1\nexport const messageYjsUpdate = 2\n\n/**\n * Create a sync step 1 message based on the state of the current shared document.\n *\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n */\nexport const writeSyncStep1 = (encoder, doc) => {\n  encoding.writeVarUint(encoder, messageYjsSyncStep1)\n  const sv = Y.encodeStateVector(doc)\n  encoding.writeVarUint8Array(encoder, sv)\n}\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n * @param {Uint8Array} [encodedStateVector]\n */\nexport const writeSyncStep2 = (encoder, doc, encodedStateVector) => {\n  encoding.writeVarUint(encoder, messageYjsSyncStep2)\n  encoding.writeVarUint8Array(encoder, Y.encodeStateAsUpdate(doc, encodedStateVector))\n}\n\n/**\n * Read SyncStep1 message and reply with SyncStep2.\n *\n * @param {decoding.Decoder} decoder The reply to the received message\n * @param {encoding.Encoder} encoder The received message\n * @param {Y.Doc} doc\n */\nexport const readSyncStep1 = (decoder, encoder, doc) =>\n  writeSyncStep2(encoder, doc, decoding.readVarUint8Array(decoder))\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nexport const readSyncStep2 = (decoder, doc, transactionOrigin) => {\n  try {\n    Y.applyUpdate(doc, decoding.readVarUint8Array(decoder), transactionOrigin)\n  } catch (error) {\n    // This catches errors that are thrown by event handlers\n    console.error('Caught error while handling a Yjs update', error)\n  }\n}\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Uint8Array} update\n */\nexport const writeUpdate = (encoder, update) => {\n  encoding.writeVarUint(encoder, messageYjsUpdate)\n  encoding.writeVarUint8Array(encoder, update)\n}\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nexport const readUpdate = readSyncStep2\n\n/**\n * @param {decoding.Decoder} decoder A message received from another client\n * @param {encoding.Encoder} encoder The reply message. Does not need to be sent if empty.\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nexport const readSyncMessage = (decoder, encoder, doc, transactionOrigin) => {\n  const messageType = decoding.readVarUint(decoder)\n  switch (messageType) {\n    case messageYjsSyncStep1:\n      readSyncStep1(decoder, encoder, doc)\n      break\n    case messageYjsSyncStep2:\n      readSyncStep2(decoder, doc, transactionOrigin)\n      break\n    case messageYjsUpdate:\n      readUpdate(decoder, doc, transactionOrigin)\n      break\n    default:\n      throw new Error('Unknown message type')\n  }\n  return messageType\n}\n", "/**\n * @module awareness-protocol\n */\n\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\nimport * as time from 'lib0/time'\nimport * as math from 'lib0/math'\nimport { Observable } from 'lib0/observable'\nimport * as f from 'lib0/function'\nimport * as Y from 'yjs' // eslint-disable-line\n\nexport const outdatedTimeout = 30000\n\n/**\n * @typedef {Object} MetaClientState\n * @property {number} MetaClientState.clock\n * @property {number} MetaClientState.lastUpdated unix timestamp\n */\n\n/**\n * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information\n * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of\n * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.\n *\n * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override\n * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is\n * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that\n * a remote client is offline, it may propagate a message with\n * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a\n * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.\n *\n * Before a client disconnects, it should propagate a `null` state with an updated clock.\n *\n * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.\n *\n * @extends {Observable<string>}\n */\nexport class Awareness extends Observable {\n  /**\n   * @param {Y.Doc} doc\n   */\n  constructor (doc) {\n    super()\n    this.doc = doc\n    /**\n     * @type {number}\n     */\n    this.clientID = doc.clientID\n    /**\n     * Maps from client id to client state\n     * @type {Map<number, Object<string, any>>}\n     */\n    this.states = new Map()\n    /**\n     * @type {Map<number, MetaClientState>}\n     */\n    this.meta = new Map()\n    this._checkInterval = /** @type {any} */ (setInterval(() => {\n      const now = time.getUnixTime()\n      if (this.getLocalState() !== null && (outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ (this.meta.get(this.clientID)).lastUpdated)) {\n        // renew local clock\n        this.setLocalState(this.getLocalState())\n      }\n      /**\n       * @type {Array<number>}\n       */\n      const remove = []\n      this.meta.forEach((meta, clientid) => {\n        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {\n          remove.push(clientid)\n        }\n      })\n      if (remove.length > 0) {\n        removeAwarenessStates(this, remove, 'timeout')\n      }\n    }, math.floor(outdatedTimeout / 10)))\n    doc.on('destroy', () => {\n      this.destroy()\n    })\n    this.setLocalState({})\n  }\n\n  destroy () {\n    this.emit('destroy', [this])\n    this.setLocalState(null)\n    super.destroy()\n    clearInterval(this._checkInterval)\n  }\n\n  /**\n   * @return {Object<string,any>|null}\n   */\n  getLocalState () {\n    return this.states.get(this.clientID) || null\n  }\n\n  /**\n   * @param {Object<string,any>|null} state\n   */\n  setLocalState (state) {\n    const clientID = this.clientID\n    const currLocalMeta = this.meta.get(clientID)\n    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1\n    const prevState = this.states.get(clientID)\n    if (state === null) {\n      this.states.delete(clientID)\n    } else {\n      this.states.set(clientID, state)\n    }\n    this.meta.set(clientID, {\n      clock,\n      lastUpdated: time.getUnixTime()\n    })\n    const added = []\n    const updated = []\n    const filteredUpdated = []\n    const removed = []\n    if (state === null) {\n      removed.push(clientID)\n    } else if (prevState == null) {\n      if (state != null) {\n        added.push(clientID)\n      }\n    } else {\n      updated.push(clientID)\n      if (!f.equalityDeep(prevState, state)) {\n        filteredUpdated.push(clientID)\n      }\n    }\n    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n      this.emit('change', [{ added, updated: filteredUpdated, removed }, 'local'])\n    }\n    this.emit('update', [{ added, updated, removed }, 'local'])\n  }\n\n  /**\n   * @param {string} field\n   * @param {any} value\n   */\n  setLocalStateField (field, value) {\n    const state = this.getLocalState()\n    if (state !== null) {\n      this.setLocalState({\n        ...state,\n        [field]: value\n      })\n    }\n  }\n\n  /**\n   * @return {Map<number,Object<string,any>>}\n   */\n  getStates () {\n    return this.states\n  }\n}\n\n/**\n * Mark (remote) clients as inactive and remove them from the list of active peers.\n * This change will be propagated to remote clients.\n *\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @param {any} origin\n */\nexport const removeAwarenessStates = (awareness, clients, origin) => {\n  const removed = []\n  for (let i = 0; i < clients.length; i++) {\n    const clientID = clients[i]\n    if (awareness.states.has(clientID)) {\n      awareness.states.delete(clientID)\n      if (clientID === awareness.clientID) {\n        const curMeta = /** @type {MetaClientState} */ (awareness.meta.get(clientID))\n        awareness.meta.set(clientID, {\n          clock: curMeta.clock + 1,\n          lastUpdated: time.getUnixTime()\n        })\n      }\n      removed.push(clientID)\n    }\n  }\n  if (removed.length > 0) {\n    awareness.emit('change', [{ added: [], updated: [], removed }, origin])\n    awareness.emit('update', [{ added: [], updated: [], removed }, origin])\n  }\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @return {Uint8Array}\n */\nexport const encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {\n  const len = clients.length\n  const encoder = encoding.createEncoder()\n  encoding.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = clients[i]\n    const state = states.get(clientID) || null\n    const clock = /** @type {MetaClientState} */ (awareness.meta.get(clientID)).clock\n    encoding.writeVarUint(encoder, clientID)\n    encoding.writeVarUint(encoder, clock)\n    encoding.writeVarString(encoder, JSON.stringify(state))\n  }\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * Modify the content of an awareness update before re-encoding it to an awareness update.\n *\n * This might be useful when you have a central server that wants to ensure that clients\n * cant hijack somebody elses identity.\n *\n * @param {Uint8Array} update\n * @param {function(any):any} modify\n * @return {Uint8Array}\n */\nexport const modifyAwarenessUpdate = (update, modify) => {\n  const decoder = decoding.createDecoder(update)\n  const encoder = encoding.createEncoder()\n  const len = decoding.readVarUint(decoder)\n  encoding.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = decoding.readVarUint(decoder)\n    const clock = decoding.readVarUint(decoder)\n    const state = JSON.parse(decoding.readVarString(decoder))\n    const modifiedState = modify(state)\n    encoding.writeVarUint(encoder, clientID)\n    encoding.writeVarUint(encoder, clock)\n    encoding.writeVarString(encoder, JSON.stringify(modifiedState))\n  }\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Uint8Array} update\n * @param {any} origin This will be added to the emitted change event\n */\nexport const applyAwarenessUpdate = (awareness, update, origin) => {\n  const decoder = decoding.createDecoder(update)\n  const timestamp = time.getUnixTime()\n  const added = []\n  const updated = []\n  const filteredUpdated = []\n  const removed = []\n  const len = decoding.readVarUint(decoder)\n  for (let i = 0; i < len; i++) {\n    const clientID = decoding.readVarUint(decoder)\n    let clock = decoding.readVarUint(decoder)\n    const state = JSON.parse(decoding.readVarString(decoder))\n    const clientMeta = awareness.meta.get(clientID)\n    const prevState = awareness.states.get(clientID)\n    const currClock = clientMeta === undefined ? 0 : clientMeta.clock\n    if (currClock < clock || (currClock === clock && state === null && awareness.states.has(clientID))) {\n      if (state === null) {\n        // never let a remote client remove this local state\n        if (clientID === awareness.clientID && awareness.getLocalState() != null) {\n          // remote client removed the local state. Do not remote state. Broadcast a message indicating\n          // that this client still exists by increasing the clock\n          clock++\n        } else {\n          awareness.states.delete(clientID)\n        }\n      } else {\n        awareness.states.set(clientID, state)\n      }\n      awareness.meta.set(clientID, {\n        clock,\n        lastUpdated: timestamp\n      })\n      if (clientMeta === undefined && state !== null) {\n        added.push(clientID)\n      } else if (clientMeta !== undefined && state === null) {\n        removed.push(clientID)\n      } else if (state !== null) {\n        if (!f.equalityDeep(state, prevState)) {\n          filteredUpdated.push(clientID)\n        }\n        updated.push(clientID)\n      }\n    }\n  }\n  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n    awareness.emit('change', [{\n      added, updated: filteredUpdated, removed\n    }, origin])\n  }\n  if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n    awareness.emit('update', [{\n      added, updated, removed\n    }, origin])\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
